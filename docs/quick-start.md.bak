---
layout: global
title: Spark Quick Start
---

* This will become a table of contents (this text will be scraped).
{:toc}

# Introduction

This document provides a quick-and-dirty look at Spark’s API. See the [programming guide]({{HOME_PATH}}/scala-programming-guide.html) for a complete reference. To follow along with this guide, you only need to have succesfully [built spark]({{HOME_PATH}}) on one machine -- all operations are demonstrated locally.

# Interactive Data Analysis with the Spark Shell

## Shell basics

Start the Spark shell by executing `./spark-shell` in the Spark directory.

Spark's primary abstraction is a distributed collection of items called a Resilient Distributed Dataset (RDD). RDD's can be created from Hadoop InputFormat's (such as HDFS files) or by transforming other RDD's. Let's make a new RDD derived from the text of the README file in the Spark source directory:

{% highlight scala %}
scala> val textFile = sc.textFile("README.md")
textFile: spark.RDD[String] = spark.MappedRDD@2ee9b6e3
{% endhighlight %}

RDD’s have actions, which return values, and transformations, which return pointers to new RDD’s. Let’s start with a few actions:

{% highlight scala %}
scala> textFile.count() // Number of items in this RDD
res0: Long = 74

scala> textFile.first() // First item in this RDD
res1: String = # Spark
{% endhighlight %}

Now let's use a transformation. We will use the `filter()` function to return a new RDD with a subset of the items in the file.

{% highlight scala %}
scala> val sparkLinesOnly = textFile.filter(line => line.contains("Spark"))
sparkLinesOnly: spark.RDD[String] = spark.FilteredRDD@7dd4af09
{% endhighlight %}

We can chain together transformations and actions:

{% highlight scala %}
scala> textFile.filter(line => line.contains("Spark")).count() // How many lines contain "Spark"?
res3: Long = 15
{% endhighlight %}

## Data flow
RDD transformations can be used for more complex computations. Lets say we want to find the line with the most words:

{% highlight scala %}
scala> textFile.map(line => line.split(" ").size).reduce((a, b) => if (a < b) {b} else {a})
res4: Long = 16
{% endhighlight %}

This first maps a line to an integer value, creating a new RDD. `reduce` is called on that RDD to find the largest line count. The arguments to map() and reduce() are scala closures. We can easily include functions declared elsewhere, or include existing functions in our anonymous closures. For instance, we can use `Math.max()` to make this code easier to understand. 

{% highlight scala %}
scala> import java.lang.Math;
import java.lang.Math

scala> textFile.map(line => line.split(" ").size).reduce((a, b) => Math.max(a, b))
res5: Int = 16
{% endhighlight %}

## Caching
Spark also supports pulling data sets into a cluster-wide cache. This is very useful when data is accessed iteratively, such as in machine learning jobs, or repeatedly, such as when small "hot data" is queried repeatedly. As a simple example, let's pull part of our file into memory:


{% highlight scala %}
scala> val linesWithSparkCached = linesWithSpark.cache()
linesWithSparkCached: spark.RDD[String] = spark.FilteredRDD@17e51082

scala> linesWithSparkCached.count()
res6: Long = 15

scala> linesWithSparkCached.count()
res7: Long = 15
{% endhighlight %}

It may seem silly to use a Spark to explore and cache a 30 line text file. The interesting part is that these same functions can be used on very large data sets, even when they are striped across tens or hundreds of nodes.

